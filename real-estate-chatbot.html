<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real Estate AI Chatbot Widget</title>
    <style>
        /* ===== RESET & BASE STYLES ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* ===== ANIMATIONS ===== */
        @keyframes pulse-glow {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 4px 15px rgba(var(--primary-rgb), 0.4);
            }
            50% {
                transform: scale(1.03);
                box-shadow: 0 6px 20px rgba(var(--primary-rgb), 0.5);
            }
        }

        @keyframes messageSlide {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes typingDots {
            0%, 60%, 100% {
                transform: translateY(0);
                opacity: 0.4;
            }
            30% {
                transform: translateY(-8px);
                opacity: 1;
            }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* ===== CSS CUSTOM PROPERTIES (THEME SYSTEM) ===== */
        :root {
            --primary-color: #000080;
            --secondary-color: #3b82f6;
            --primary-rgb: 0, 44, 109;
            --secondary-rgb: 0, 64, 128;
            --success-color: #4caf50;
            --error-color: #f44336;
            --background-color: #fafafa;
            --text-color: #333;
            --light-text: #666;
            --border-color: #eee;
            --shadow-light: 0 2px 8px rgba(0, 0, 0, 0.1);
            --shadow-medium: 0 4px 15px rgba(0, 0, 0, 0.15);
            --shadow-heavy: 0 10px 40px rgba(0, 0, 0, 0.15);
            --border-radius: 20px;
            --border-radius-small: 8px;
            --transition: all 0.3s ease;
        }

        /* ===== CHATBOT TOGGLE BUTTON ===== */
        .chatbot-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            border-radius: 50%;
            border: none;
            cursor: pointer;
            animation: pulse-glow 2.5s ease-in-out infinite;
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition);
        }

        .chatbot-toggle:hover {
            animation: none;
            transform: scale(1.12);
            box-shadow: 0 8px 25px rgba(var(--primary-rgb), 0.6);
        }

        .chatbot-toggle:focus {
            outline: 2px solid rgba(var(--primary-rgb), 0.7);
            outline-offset: 2px;
            animation: none;
        }

        .chatbot-toggle svg {
            width: 28px;
            height: 28px;
            fill: white;
        }

        /* ===== CHAT WIDGET CONTAINER ===== */
        .chatbot-widget {
            position: fixed;
            bottom: 90px;
            right: 20px;
            width: 350px;
            height: 450px;
            background: white;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-heavy);
            z-index: 10000;
            transform: scale(0) translateY(20px);
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .chatbot-widget.open {
            transform: scale(1) translateY(0);
            opacity: 1;
        }

        /* ===== CHAT HEADER ===== */
        .chat-header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            padding: 20px;
            border-radius: var(--border-radius) var(--border-radius) 0 0;
            flex-shrink: 0;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            position: relative;
        }

        .chat-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 50%;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.05) 0%, rgba(255, 255, 255, 0) 100%);
            pointer-events: none;
            border-radius: var(--border-radius) var(--border-radius) 0 0;
        }

        .header-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: relative;
            z-index: 1;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .bot-avatar.header-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: pulse-glow 3s ease-in-out infinite;
            border: 2px solid white;
            overflow: hidden;
            background-color: white;
            transition: var(--transition);
        }

        .bot-avatar.header-avatar:hover {
            animation: none;
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
        }

        .bot-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .header-info h3 {
            color: white;
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 2px;
        }

        .online-status {
            display: flex;
            align-items: center;
            gap: 6px;
            color: rgba(255, 255, 255, 0.9);
            font-size: 12px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            background: var(--success-color);
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .status-dot.failed {
            background: var(--error-color);
            animation: none;
        }

        .status-dot.rate-limited {
            background: #ff9800;
            animation: pulse 1s infinite;
        }

        .close-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            color: white;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition);
            backdrop-filter: blur(5px);
        }

        .close-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            border-color: rgba(255, 255, 255, 0.4);
            transform: scale(1.1) rotate(90deg);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .close-btn:focus {
            outline: 2px solid rgba(255, 255, 255, 0.8);
            outline-offset: 2px;
        }

        .close-btn svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        /* ===== CHAT MESSAGES ===== */
        .chat-messages {
            flex-grow: 1;
            overflow-y: auto;
            padding: 20px;
            background: var(--background-color);
            min-height: 0;
        }

        .chat-messages::-webkit-scrollbar {
            width: 6px;
        }

        .chat-messages::-webkit-scrollbar-track {
            background: transparent;
        }

        .chat-messages::-webkit-scrollbar-thumb {
            background: #b0b0b0;
            border-radius: 3px;
        }

        .message {
            display: flex;
            margin-bottom: 16px;
            animation: messageSlide 0.3s ease-out;
        }

        .message-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            margin: 0 8px;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            box-shadow: var(--shadow-light);
        }

        .bot-avatar.message-avatar {
            background-color: #e9ecef;
            border: 1px solid #d1d1d1;
        }

        .user-message-avatar {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            border: 1px solid var(--primary-color);
            color: white;
            font-weight: bold;
            font-size: 14px;
        }

        .message-content {
            max-width: 75%;
            padding: 12px 16px;
            border-radius: 18px;
            font-size: 14px;
            line-height: 1.4;
        }

        /* ===== PROPERTY CARD STYLES ===== */
        .property-card {
            border: 1px solid #e0e0e0;
            border-radius: 12px;
            margin: 8px 0;
            overflow: hidden;
            background: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: var(--transition);
        }

        .property-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.15);
        }

        .property-image {
            width: 100%;
            height: 120px;
            object-fit: cover;
            background: #f0f0f0;
        }

        .property-details {
            padding: 12px;
        }

        .property-title {
            font-weight: 600;
            font-size: 14px;
            color: var(--text-color);
            margin-bottom: 6px;
            line-height: 1.3;
        }

        .property-price {
            font-size: 16px;
            font-weight: 700;
            color: var(--primary-color);
            margin-bottom: 6px;
        }

        .property-specs {
            display: flex;
            gap: 12px;
            font-size: 12px;
            color: var(--light-text);
            margin-bottom: 8px;
        }

        .property-location {
            font-size: 12px;
            color: var(--light-text);
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .property-link {
            display: inline-block;
            margin-top: 8px;
            padding: 6px 12px;
            background: var(--primary-color);
            color: white;
            text-decoration: none;
            border-radius: 6px;
            font-size: 12px;
            transition: var(--transition);
        }

        .property-link:hover {
            background: var(--secondary-color);
            transform: translateY(-1px);
        }

        /* Markdown styling */
        .message-content h1, .message-content h2, .message-content h3 {
            margin: 8px 0 4px 0;
            font-weight: 600;
        }

        .message-content h1 { font-size: 18px; }
        .message-content h2 { font-size: 16px; }
        .message-content h3 { font-size: 15px; }

        .message-content p {
            margin: 4px 0;
        }

        .message-content ul, .message-content ol {
            margin: 8px 0;
            padding-left: 20px;
        }

        .message-content li {
            margin: 2px 0;
        }

        .message-content code {
            background: rgba(0, 0, 0, 0.05);
            padding: 2px 4px;
            border-radius: 3px;
            font-family: monospace;
        }

        .message-content pre {
            background: rgba(0, 0, 0, 0.05);
            padding: 8px;
            border-radius: 6px;
            overflow-x: auto;
            margin: 8px 0;
        }

        .message-content blockquote {
            border-left: 3px solid #ddd;
            margin: 8px 0;
            padding-left: 12px;
            color: var(--light-text);
        }

        .bot-message .message-content {
            background: #e9ecef;
            color: var(--text-color);
            border-bottom-left-radius: 6px;
            box-shadow: var(--shadow-light);
        }

        .user-message {
            justify-content: flex-end;
        }

        .user-message .message-content {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            border-bottom-right-radius: 6px;
            box-shadow: 0 2px 8px rgba(var(--primary-rgb), 0.2);
        }

        /* ===== TYPING INDICATOR ===== */
        .typing-indicator-message {
            display: flex;
            margin-bottom: 16px;
            animation: messageSlide 0.3s ease-out;
        }

        .typing-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 16px;
            background: #e9ecef;
            color: var(--light-text);
            border-radius: 18px;
            border-bottom-left-radius: 6px;
            box-shadow: var(--shadow-light);
            max-width: 80px;
        }

        .typing-dots {
            display: flex;
            gap: 4px;
            align-items: center;
        }

        .typing-dot {
            width: 8px;
            height: 8px;
            background: #999;
            border-radius: 50%;
            animation: typingDots 1.4s infinite ease-in-out;
        }

        .typing-dot:nth-child(1) { animation-delay: 0s; }
        .typing-dot:nth-child(2) { animation-delay: 0.2s; }
        .typing-dot:nth-child(3) { animation-delay: 0.4s; }

        /* ===== CHAT INPUT ===== */
        .chat-input {
            padding: 15px 20px;
            background: white;
            border-top: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .input-container {
            display: flex;
            align-items: center;
            gap: 10px;
            background: #f8f9fa;
            border-radius: 25px;
            padding: 6px 12px;
            border: 2px solid transparent;
            transition: var(--transition);
        }

        .input-container:focus-within {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(var(--primary-rgb), 0.2);
        }

        .attachment-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 6px;
            color: #B0B0B0;
            border-radius: 50%;
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
        }

        .attachment-btn:hover {
            background-color: #f0f0f0;
            color: #888;
            transform: scale(1.1);
        }

        .attachment-btn:focus {
            outline: 2px solid #B0B0B0;
            outline-offset: 2px;
        }

        .attachment-btn svg {
            width: 18px;
            height: 18px;
            stroke: currentColor;
            fill: none;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .message-input {
            flex: 1;
            border: none;
            background: none;
            outline: none;
            font-size: 14px;
            padding: 8px 0;
        }

        .message-input::placeholder {
            color: #999;
        }

        .send-btn {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            border: none;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition);
        }

        .send-btn:hover, .send-btn:focus {
            transform: scale(1.1);
            box-shadow: 0 2px 8px rgba(var(--primary-rgb), 0.3);
            outline: none;
        }

        .send-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .send-btn svg {
            width: 16px;
            height: 16px;
            fill: white;
        }

        /* ===== ERROR MESSAGE ===== */
        .error-message {
            background-color: #ffebee;
            color: #c62828;
            border: 1px solid #ffcdd2;
            padding: 10px 15px;
            border-radius: var(--border-radius-small);
            margin-bottom: 15px;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .error-message svg {
            flex-shrink: 0;
            width: 18px;
            height: 18px;
            fill: #c62828;
        }

        /* ===== RATE LIMIT WARNING ===== */
        .rate-limit-warning {
            background-color: #fff3e0;
            color: #e65100;
            border: 1px solid #ffcc02;
            padding: 10px 15px;
            border-radius: var(--border-radius-small);
            margin-bottom: 15px;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* ===== RESPONSIVE DESIGN ===== */
        @media (max-width: 480px) {
            .chatbot-widget {
                bottom: 10px;
                left: 10px;
                right: 10px;
                width: auto;
                height: 70vh;
                max-height: 450px;
                border-radius: 15px;
            }

            .chatbot-toggle {
                bottom: 15px;
                right: 15px;
                width: 55px;
                height: 55px;
            }

            .chat-header {
                padding: 15px;
            }

            .header-info h3 {
                font-size: 16px;
            }

            .chat-input {
                padding: 10px 15px;
            }
        }
    </style>
</head>
<body>
    <!-- Chat Toggle Button -->
    <button id="chatbot-toggle" class="chatbot-toggle" aria-label="Open chat">
        <svg viewBox="0 0 24 24" aria-hidden="true">
            <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
        </svg>
    </button>

    <!-- Chat Widget -->
    <div id="chatbot-widget" class="chatbot-widget" role="dialog" aria-labelledby="chat-title" aria-modal="true" tabindex="-1">
        <!-- Chat Header -->
        <div class="chat-header">
            <div class="header-content">
                <div class="header-left">
                    <div class="bot-avatar header-avatar">
                        <img id="header-bot-avatar" src="" alt="" aria-hidden="true">
                    </div>
                    <div class="header-info">
                        <h3 id="chat-title">Real Estate Agent</h3>
                        <div class="online-status">
                            <div class="status-dot" id="status-dot" aria-hidden="true"></div>
                            <span class="sr-only" id="status-text">Online</span>
                            <span id="status-message">Online</span>
                        </div>
                    </div>
                </div>
                <button class="close-btn" id="close-chat" aria-label="Close chat">
                    <svg viewBox="0 0 24 24" aria-hidden="true">
                        <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                    </svg>
                </button>
            </div>
        </div>

        <!-- Chat Messages -->
        <div class="chat-messages" id="chat-messages" aria-live="polite" aria-atomic="true">
            <!-- Messages will be appended here -->
        </div>

        <!-- Chat Input -->
        <div class="chat-input">
            <div class="input-container">
                <button class="attachment-btn" id="attachment-btn" aria-label="Attach file">
                    <svg viewBox="0 0 24 24">
                        <path d="m21.44 11.05-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66L9.64 16.2a2 2 0 0 1-2.83-2.83l8.49-8.49"/>
                    </svg>
                </button>
                <input type="text" id="message-input" class="message-input" placeholder="Ask about properties..." aria-label="Type your message">
                <button class="send-btn" id="send-btn" aria-label="Send message">
                    <svg viewBox="0 0 24 24" aria-hidden="true">
                        <path d="M2,21L23,12L2,3V10L17,12L2,14V21Z"/>
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <script>
        /**
         * Rate Limiter Class - More forgiving rate limiting
         */
        class RateLimiter {
            constructor(maxRequests = 20, timeWindow = 60000) { // Increased to 20 requests per minute
                this.maxRequests = maxRequests;
                this.timeWindow = timeWindow;
                this.requests = [];
                this.retryAfter = 0;
            }

            canMakeRequest() {
                const now = Date.now();
                
                // Check if we're in a retry-after period
                if (this.retryAfter > now) {
                    return false;
                }

                // Remove old requests outside the time window
                this.requests = this.requests.filter(time => now - time < this.timeWindow);
                
                return this.requests.length < this.maxRequests;
            }

            recordRequest() {
                this.requests.push(Date.now());
            }

            setRetryAfter(seconds) {
                this.retryAfter = Date.now() + (seconds * 1000);
            }

            getWaitTime() {
                const now = Date.now();
                if (this.retryAfter > now) {
                    return Math.ceil((this.retryAfter - now) / 1000);
                }
                
                if (this.requests.length >= this.maxRequests) {
                    const oldestRequest = Math.min(...this.requests);
                    const waitTime = Math.ceil((this.timeWindow - (now - oldestRequest)) / 1000);
                    return Math.max(waitTime, 1);
                }
                
                return 0;
            }
        }

        /**
         * Enhanced Property Fetcher with basic regex-only filter extraction
         */
        class PropertyFetcher {
            constructor(apiUrl) {
                this.apiUrl = apiUrl;
                this.cache = new Map();
                this.cacheTimeout = 5 * 60 * 1000; // 5 minutes
                this.rateLimiter = new RateLimiter(10, 60000); // 10 requests per minute for properties
            }

            /**
             * Generate cache key from filters
             */
            getCacheKey(filters) {
                return JSON.stringify(filters);
            }

            /**
             * Check if cached data is still valid
             */
            isCacheValid(timestamp) {
                return Date.now() - timestamp < this.cacheTimeout;
            }

            /**
             * Basic filter extraction using ONLY regex patterns - NO AI CALLS
             */
            extractFilters(userMessage) {
                const filters = {};
                const lowerMessage = userMessage.toLowerCase();

                // Extract location using more comprehensive patterns
                const locationPatterns = [
                    /(?:in|at|near|around|from)\s+([a-zA-Z\s]+?)(?:\s(?:under|below|above|over|with|for|\d|$)|,|$)/i,
                    /(?:^|\s)([a-zA-Z\s]{2,15})(?:\s(?:properties|property|houses|house|apartments|apartment|villas|villa|area|district|city))/i
                ];
                
                for (const pattern of locationPatterns) {
                    const match = lowerMessage.match(pattern);
                    if (match && match[1]) {
                        const location = match[1].trim();
                        // Filter out common non-location words
                        const excludeWords = ['looking', 'want', 'need', 'find', 'search', 'show', 'budget', 'price', 'cost', 'bedroom', 'bathroom', 'square', 'feet'];
                        if (!excludeWords.some(word => location.includes(word)) && location.length > 2) {
                            filters.location = location;
                            break;
                        }
                    }
                }

                // Extract price range with improved patterns
                const maxPricePatterns = [
                    /(?:under|below|max|maximum|up to|less than)\s*\$?([0-9,]+(?:\s?(?:million|mil|m|k|thousand))?)/i,
                    /budget.*?(?:of|is|around)?\s*\$?([0-9,]+(?:\s?(?:million|mil|m|k|thousand))?)/i
                ];
                
                for (const pattern of maxPricePatterns) {
                    const match = lowerMessage.match(pattern);
                    if (match) {
                        let price = match[1].replace(/,/g, '');
                        if (price.includes('million') || price.includes('mil') || price.includes('m')) {
                            price = parseInt(price) * 1000000;
                        } else if (price.includes('k') || price.includes('thousand')) {
                            price = parseInt(price) * 1000;
                        } else {
                            price = parseInt(price);
                        }
                        if (!isNaN(price)) {
                            filters.max_price = price;
                            break;
                        }
                    }
                }

                const minPricePatterns = [
                    /(?:above|over|min|minimum|more than|starting)\s*\$?([0-9,]+(?:\s?(?:million|mil|m|k|thousand))?)/i
                ];
                
                for (const pattern of minPricePatterns) {
                    const match = lowerMessage.match(pattern);
                    if (match) {
                        let price = match[1].replace(/,/g, '');
                        if (price.includes('million') || price.includes('mil') || price.includes('m')) {
                            price = parseInt(price) * 1000000;
                        } else if (price.includes('k') || price.includes('thousand')) {
                            price = parseInt(price) * 1000;
                        } else {
                            price = parseInt(price);
                        }
                        if (!isNaN(price)) {
                            filters.min_price = price;
                            break;
                        }
                    }
                }

                // Extract bedrooms with improved patterns
                const bedroomPatterns = [
                    /(\d+)\s*(?:bed|bedroom|br)/i,
                    /(?:with|need|want)\s*(\d+)\s*(?:bed|bedroom)/i
                ];
                
                for (const pattern of bedroomPatterns) {
                    const match = lowerMessage.match(pattern);
                    if (match) {
                        const beds = parseInt(match[1]);
                        if (beds > 0 && beds <= 10) {
                            filters.min_bedrooms = beds;
                            break;
                        }
                    }
                }

                // Extract property type with more comprehensive patterns
                const propertyTypeMap = {
                    'apartment': ['apartment', 'apartments', 'apt', 'apts', 'flat', 'flats'],
                    'house': ['house', 'houses', 'home', 'homes'],
                    'villa': ['villa', 'villas'],
                    'condo': ['condo', 'condos', 'condominium', 'condominiums'],
                    'townhouse': ['townhouse', 'townhouses', 'townhome', 'townhomes'],
                    'penthouse': ['penthouse', 'penthouses'],
                    'studio': ['studio', 'studios']
                };
                
                for (const [type, keywords] of Object.entries(propertyTypeMap)) {
                    if (keywords.some(keyword => lowerMessage.includes(keyword))) {
                        filters.property_type = type;
                        break;
                    }
                }

                console.log("Extracted filters (regex only):", filters);
                return filters;
            }

            /**
             * Fetch properties from WordPress REST API with caching and rate limiting
             */
            async fetchProperties(filters = {}) {
                const cacheKey = this.getCacheKey(filters);
                
                // Check cache first
                if (this.cache.has(cacheKey)) {
                    const cached = this.cache.get(cacheKey);
                    if (this.isCacheValid(cached.timestamp)) {
                        console.log("Returning cached properties");
                        return cached.data;
                    } else {
                        this.cache.delete(cacheKey);
                    }
                }

                // Check rate limit
                if (!this.rateLimiter.canMakeRequest()) {
                    const waitTime = this.rateLimiter.getWaitTime();
                    throw new Error(`Too many requests. Please wait ${waitTime} seconds and try again.`);
                }

                try {
                    this.rateLimiter.recordRequest();

                    const queryParams = new URLSearchParams();
                    
                    // Add search parameter for location
                    if (filters.location) {
                        queryParams.append('search', filters.location);
                    }

                    // Add custom meta query parameters
                    if (filters.max_price) {
                        queryParams.append('max_price', filters.max_price);
                    }
                    if (filters.min_price) {
                        queryParams.append('min_price', filters.min_price);
                    }
                    if (filters.min_bedrooms) {
                        queryParams.append('min_bedrooms', filters.min_bedrooms);
                    }
                    if (filters.max_bedrooms) {
                        queryParams.append('max_bedrooms', filters.max_bedrooms);
                    }
                    if (filters.property_type) {
                        queryParams.append('property_type', filters.property_type);
                    }

                    // Limit results for performance
                    queryParams.append('per_page', '6');
                    queryParams.append('orderby', 'date');
                    queryParams.append('order', 'desc');
                    queryParams.append('_embed', 'true'); // Include featured media

                    const url = `${this.apiUrl}?${queryParams.toString()}`;
                    console.log("Fetching properties from:", url);

                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 15000); // 15 second timeout

                    const response = await fetch(url, {
                        signal: controller.signal,
                        headers: {
                            'Accept': 'application/json',
                            'Cache-Control': 'no-cache'
                        }
                    });
                    
                    clearTimeout(timeoutId);

                    if (response.status === 429) {
                        const retryAfter = response.headers.get('retry-after') || 60;
                        this.rateLimiter.setRetryAfter(parseInt(retryAfter));
                        throw new Error(`Too many requests. Please wait ${retryAfter} seconds and try again.`);
                    }

                    if (!response.ok) {
                        throw new Error(`HTTP Error: ${response.status} - ${response.statusText}`);
                    }

                    const properties = await response.json();
                    const result = Array.isArray(properties) ? properties : [];
                    
                    // Cache the result
                    this.cache.set(cacheKey, {
                        data: result,
                        timestamp: Date.now()
                    });

                    return result;
                    
                } catch (error) {
                    if (error.name === 'AbortError') {
                        throw new Error('Request timeout. Please try again.');
                    }
                    console.error("Error fetching properties:", error);
                    throw error;
                }
            }

            /**
             * Format properties for AI context
             */
            formatPropertiesForAI(properties) {
                if (!properties || properties.length === 0) {
                    return "No properties found matching your criteria.";
                }

                return properties.map((property, index) => {
                    const title = property.title?.rendered || 'Untitled Property';
                    const price = this.getMetaValue(property, 'price') || 'Price not available';
                    const location = this.getMetaValue(property, 'location') || 'Location not specified';
                    const bedrooms = this.getMetaValue(property, 'bedrooms') || 'N/A';
                    const bathrooms = this.getMetaValue(property, 'bathrooms') || 'N/A';
                    const area = this.getMetaValue(property, 'area') || 'N/A';
                    const propertyType = this.getMetaValue(property, 'property_type') || 'Property';
                    
                    return `${index + 1}. ${title}
   - Price: $${price}
   - Location: ${location}
   - Type: ${propertyType}
   - Bedrooms: ${bedrooms}
   - Bathrooms: ${bathrooms}
   - Area: ${area} sq ft
   - Link: ${property.link || '#'}`;
                }).join('\n\n');
            }

            /**
             * Get meta value from property object
             */
            getMetaValue(property, key) {
                // Try different possible meta field locations
                if (property.meta && property.meta[key]) {
                    return property.meta[key];
                }
                if (property.acf && property.acf[key]) {
                    return property.acf[key];
                }
                if (property[key]) {
                    return property[key];
                }
                // Try alternative field names
                const alternativeKeys = {
                    'price': ['property_price', 'listing_price', 'cost'],
                    'location': ['property_location', 'address', 'city'],
                    'bedrooms': ['beds', 'bedroom_count'],
                    'bathrooms': ['baths', 'bathroom_count'],
                    'area': ['square_feet', 'size', 'property_size'],
                    'property_type': ['type', 'listing_type']
                };
                
                if (alternativeKeys[key]) {
                    for (const altKey of alternativeKeys[key]) {
                        if (property.meta && property.meta[altKey]) return property.meta[altKey];
                        if (property.acf && property.acf[altKey]) return property.acf[altKey];
                        if (property[altKey]) return property[altKey];
                    }
                }
                
                return null;
            }

            /**
             * Format properties for display in chat
             */
            formatPropertiesForDisplay(properties) {
                if (!properties || properties.length === 0) {
                    return null;
                }

                return properties.map(property => {
                    const title = property.title?.rendered || 'Untitled Property';
                    const price = this.getMetaValue(property, 'price');
                    const location = this.getMetaValue(property, 'location');
                    const bedrooms = this.getMetaValue(property, 'bedrooms');
                    const bathrooms = this.getMetaValue(property, 'bathrooms');
                    const area = this.getMetaValue(property, 'area');
                    const propertyType = this.getMetaValue(property, 'property_type');
                    const image = this.getPropertyImage(property);
                    const link = property.link || '#';

                    return {
                        title,
                        price: price ? `$${parseInt(price).toLocaleString()}` : 'Price on request',
                        location: location || 'Location not specified',
                        bedrooms: bedrooms || 'N/A',
                        bathrooms: bathrooms || 'N/A',
                        area: area ? `${area} sq ft` : 'N/A',
                        propertyType: propertyType || 'Property',
                        image,
                        link
                    };
                });
            }

            /**
             * Get property image URL
             */
            getPropertyImage(property) {
                // Try to get featured image from _embedded
                if (property._embedded && property._embedded['wp:featuredmedia']) {
                    const media = property._embedded['wp:featuredmedia'][0];
                    if (media && media.source_url) {
                        return media.source_url;
                    }
                }
                
                // Try meta fields for image
                const imageUrl = this.getMetaValue(property, 'featured_image') || 
                                this.getMetaValue(property, 'image') ||
                                this.getMetaValue(property, 'gallery_image') ||
                                this.getMetaValue(property, 'thumbnail');
                
                if (imageUrl) {
                    return imageUrl;
                }

                // Fallback placeholder
                return 'https://via.placeholder.com/300x200/e0e0e0/666666?text=Property+Image';
            }
        }

        /**
         * Simple Markdown Parser for formatting bot messages
         */
        class MarkdownParser {
            static parse(text) {
                if (!text) return '';
                
                text = this.sanitizeHTML(text);
                
                return text
                    .replace(/^### (.*$)/gim, '<h3>$1</h3>')
                    .replace(/^## (.*$)/gim, '<h2>$1</h2>')
                    .replace(/^# (.*$)/gim, '<h1>$1</h1>')
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/__(.*?)__/g, '<strong>$1</strong>')
                    .replace(/\*(.*?)\*/g, '<em>$1</em>')
                    .replace(/_(.*?)_/g, '<em>$1</em>')
                    .replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>')
                    .replace(/`([^`]+)`/g, '<code>$1</code>')
                    .replace(/^> (.*$)/gim, '<blockquote>$1</blockquote>')
                    .replace(/^\* (.*$)/gim, '<li>$1</li>')
                    .replace(/(<li>.*<\/li>)/gs, '<ul>$1</ul>')
                    .replace(/^\d+\. (.*$)/gim, '<li>$1</li>')
                    .replace(/\n\n/g, '</p><p>')
                    .replace(/\n/g, '<br>')
                    .replace(/^(?!<[h|u|o|p|b])/gm, '<p>')
                    .replace(/(?<!>)$/gm, '</p>')
                    .replace(/<p><\/p>/g, '')
                    .replace(/<p>(<[h|u|o|b])/g, '$1')
                    .replace(/(<\/[h|u|o|b][^>]*>)<\/p>/g, '$1');
            }
            
            static sanitizeHTML(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
        }

        /**
         * Intent Analyzer - Determines if user wants to search for properties
         */
        class IntentAnalyzer {
            static analyzeIntent(message) {
                const lowerMessage = message.toLowerCase();
                
                // Greeting patterns
                const greetingPatterns = [
                    /^(hi|hello|hey|good morning|good afternoon|good evening|greetings)[\s\W]*$/i,
                    /^(what's up|how are you|howdy)[\s\W]*$/i
                ];
                
                // General conversation patterns
                const generalPatterns = [
                    /^(thank you|thanks|bye|goodbye|see you|take care)[\s\W]*$/i,
                    /^(how are you|what can you do|who are you|help)[\s\W]*$/i,
                    /^(ok|okay|yes|no|sure|alright)[\s\W]*$/i
                ];
                
                // Property search patterns - Enhanced
                const searchPatterns = [
                    /(find|search|show|looking for|want|need|interested in).*?(property|properties|house|houses|apartment|apartments|villa|villas|condo|condos|home|homes)/i,
                    /(budget|price|cost|expensive|cheap|affordable|under|over|million|thousand)/i,
                    /(bedroom|bedrooms|bed|beds|bathroom|bathrooms|bath|baths)/i,
                    /(location|area|neighborhood|city|town|district|in\s+[a-zA-Z]+)/i,
                    /(buy|purchase|rent|rental|lease|sale|for sale)/i,
                    /(real estate|realty|property market)/i,
                    /(villa|apartment|house|condo|penthouse|townhouse|studio)/i
                ];
                
                // Check for greeting
                if (greetingPatterns.some(pattern => pattern.test(lowerMessage))) {
                    return { intent: 'greeting', confidence: 0.9 };
                }
                
                // Check for general conversation
                if (generalPatterns.some(pattern => pattern.test(lowerMessage))) {
                    return { intent: 'general', confidence: 0.8 };
                }
                
                // Check for property search intent
                const searchMatches = searchPatterns.filter(pattern => pattern.test(lowerMessage));
                if (searchMatches.length > 0) {
                    return { intent: 'property_search', confidence: Math.min(0.9, 0.4 + (searchMatches.length * 0.2)) };
                }
                
                // Default to general if unsure
                return { intent: 'general', confidence: 0.5 };
            }
        }

        /**
         * Enhanced Real Estate ChatBot Class - Optimized for fewer API calls
         */
        class RealEstateChatBot {
            constructor(config = {}) {
                this.config = this.mergeConfig(config);
                this.state = {
                    isOpen: false,
                    isTyping: false,
                    conversationMemory: [],
                    maxMemorySize: 10,
                    userContext: {
                        hasGreeted: false,
                        isSearching: false,
                        lastSearchFilters: null
                    }
                };
                
                this.propertyFetcher = new PropertyFetcher(this.config.propertyApiUrl);
                this.rateLimiter = new RateLimiter(20, 60000); // More forgiving: 20 AI requests per minute
                this.elements = this.initializeElements();
                this.setupEventListeners();
                this.applyConfiguration();
                this.showInitialMessage();
                this.updateConnectionStatus('online');
            }

            /**
             * Merge user config with defaults
             */
            mergeConfig(userConfig) {
                const defaultConfig = {
                    // Bot Configuration
                    botName: 'Real Estate Agent',
                    botAvatarHeaderUrl: 'https://cdn-icons-png.flaticon.com/256/3135/3135715.png',
                    botAvatarMessageUrl: 'https://cdn-icons-png.flaticon.com/256/3135/3135715.png',
                    userAvatarUrl: 'https://cdn-icons-png.flaticon.com/256/9131/9131529.png',
                    
                    // Theme Colors
                    primaryColor: '#000080',
                    secondaryColor: '#3b82f6',
                    
                    // Messages Configuration
                    initialMessage: "🏠 Hello! I'm your AI real estate agent. I'm here to help you find the perfect property. Just tell me what you're looking for - location, budget, property type, or any specific features you need!",
                    
                    // API Configuration
                    apiKey: 'YOUR_OPENROUTER_API_KEY_HERE',
                    apiUrl: 'https://openrouter.ai/api/v1/chat/completions',
                    model: 'mistralai/mistral-small-3.2-24b-instruct:free',
                    maxTokens: 800,
                    temperature: 0.7,
                    
                    // Property API Configuration
                    propertyApiUrl: 'https://yourdomain.com/wp-json/wp/v2/property',
                    
                    // Behavior Configuration
                    enableAttachments: false,
                    enableMarkdown: true,
                    autoCloseOnOutsideClick: false,
                    showTypingIndicator: true,
                    errorRetryAttempts: 3
                };
                
                return { ...defaultConfig, ...userConfig };
            }

            /**
             * Initialize DOM elements
             */
            initializeElements() {
                return {
                    toggle: document.getElementById('chatbot-toggle'),
                    widget: document.getElementById('chatbot-widget'),
                    closeBtn: document.getElementById('close-chat'),
                    messageInput: document.getElementById('message-input'),
                    sendBtn: document.getElementById('send-btn'),
                    messagesContainer: document.getElementById('chat-messages'),
                    attachmentBtn: document.getElementById('attachment-btn'),
                    headerTitle: document.getElementById('chat-title'),
                    headerAvatar: document.getElementById('header-bot-avatar'),
                    statusDot: document.getElementById('status-dot'),
                    statusText: document.getElementById('status-text'),
                    statusMessage: document.getElementById('status-message')
                };
            }

            /**
             * Apply user configuration to UI elements
             */
            applyConfiguration() {
                this.applyTheme();
                
                this.elements.headerTitle.textContent = this.config.botName;
                
                this.elements.headerAvatar.src = this.config.botAvatarHeaderUrl;
                this.elements.headerAvatar.alt = `${this.config.botName} Avatar`;
                this.elements.headerAvatar.onerror = () => {
                    this.elements.headerAvatar.style.display = 'none';
                    this.elements.headerAvatar.parentElement.innerHTML = '🏠';
                    this.elements.headerAvatar.parentElement.style.fontSize = '20px';
                };
                
                if (!this.config.enableAttachments) {
                    this.elements.attachmentBtn.style.display = 'none';
                }
            }

            /**
             * Apply theme colors using CSS custom properties
             */
            applyTheme() {
                const root = document.documentElement;
                root.style.setProperty('--primary-color', this.config.primaryColor);
                root.style.setProperty('--secondary-color', this.config.secondaryColor);
                
                const primaryRgb = this.hexToRgb(this.config.primaryColor);
                const secondaryRgb = this.hexToRgb(this.config.secondaryColor);
                
                if (primaryRgb) {
                    root.style.setProperty('--primary-rgb', `${primaryRgb.r}, ${primaryRgb.g}, ${primaryRgb.b}`);
                }
                if (secondaryRgb) {
                    root.style.setProperty('--secondary-rgb', `${secondaryRgb.r}, ${secondaryRgb.g}, ${secondaryRgb.b}`);
                }
            }

            /**
             * Convert hex color to RGB object
             */
            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : null;
            }

            /**
             * Setup all event listeners
             */
            setupEventListeners() {
                this.elements.toggle.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.toggleChat();
                });

                this.elements.closeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.closeChat();
                });

                this.elements.sendBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    this.sendMessage();
                });

                this.elements.messageInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.sendMessage();
                    }
                });

                this.elements.widget.addEventListener('click', (e) => {
                    e.stopPropagation();
                });

                if (this.config.autoCloseOnOutsideClick) {
                    document.addEventListener('click', (e) => {
                        if (this.state.isOpen && 
                            !this.elements.widget.contains(e.target) && 
                            !this.elements.toggle.contains(e.target)) {
                            this.closeChat();
                        }
                    });
                }

                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && this.state.isOpen) {
                        this.closeChat();
                    }
                });
            }

            /**
             * Toggle chat open/close state
             */
            toggleChat() {
                if (this.state.isOpen) {
                    this.closeChat();
                } else {
                    this.openChat();
                }
            }

            /**
             * Open the chat widget
             */
            openChat() {
                this.elements.widget.classList.add('open');
                this.elements.toggle.setAttribute('aria-label', 'Close chat');
                this.elements.widget.setAttribute('aria-hidden', 'false');
                this.state.isOpen = true;
                
                setTimeout(() => {
                    this.elements.messageInput.focus();
                    this.scrollToBottom();
                }, 350);
            }

            /**
             * Close the chat widget
             */
            closeChat() {
                this.elements.widget.classList.remove('open');
                this.elements.toggle.setAttribute('aria-label', 'Open chat');
                this.elements.widget.setAttribute('aria-hidden', 'true');
                this.elements.toggle.focus();
                this.state.isOpen = false;
            }

            /**
             * Send user message
             */
            async sendMessage() {
                const message = this.elements.messageInput.value.trim();
                if (message && !this.state.isTyping) {
                    this.addMessage(message, 'user');
                    this.elements.messageInput.value = '';
                    this.elements.sendBtn.disabled = true;
                    
                    await this.processUserMessage(message);
                    
                    this.elements.sendBtn.disabled = false;
                }
            }

            /**
             * Process user message with optimized workflow (1 AI call per message max)
             */
            async processUserMessage(message) {
                try {
                    this.updateConnectionStatus('online');
                    
                    if (this.config.showTypingIndicator) {
                        this.showTypingIndicator();
                    }

                    // Analyze user intent
                    const intentAnalysis = IntentAnalyzer.analyzeIntent(message);
                    console.log("Intent analysis:", intentAnalysis);

                    let botResponse;
                    let properties = [];

                    // Handle based on intent with ONLY 1 AI call per message
                    if (intentAnalysis.intent === 'greeting' && !this.state.userContext.hasGreeted) {
                        // Handle greeting - Simple predefined response (NO AI CALL)
                        botResponse = this.getPredefinedGreeting();
                        this.state.userContext.hasGreeted = true;
                        
                    } else if (intentAnalysis.intent === 'property_search' || this.state.userContext.isSearching) {
                        // Handle property search with optimized workflow
                        const searchResult = await this.handlePropertySearchOptimized(message);
                        botResponse = searchResult.response;
                        properties = searchResult.properties;
                        this.state.userContext.isSearching = true;
                        
                    } else {
                        // Handle general conversation - 1 AI call
                        if (!this.rateLimiter.canMakeRequest()) {
                            botResponse = this.getPredefinedResponse(message);
                        } else {
                            botResponse = await this.handleGeneralConversation(message);
                        }
                    }
                    
                    if (this.config.showTypingIndicator) {
                        this.hideTypingIndicator();
                    }
                    
                    // Add the response to memory and display
                    this.addToMemory(message, botResponse);
                    this.addMessage(botResponse, 'bot');

                    // Display property cards if properties were found
                    if (properties && properties.length > 0) {
                        setTimeout(() => {
                            this.displayPropertyCards(properties);
                        }, 300);
                    }
                    
                } catch (error) {
                    if (this.config.showTypingIndicator) {
                        this.hideTypingIndicator();
                    }
                    
                    this.handleAPIError(error);
                }
            }

            /**
             * Get predefined greeting response (NO AI CALL)
             */
            getPredefinedGreeting() {
                const greetings = [
                    "Hello! 👋 I'm your AI real estate agent, and I'm excited to help you find your perfect property! Whether you're looking for a cozy apartment, a spacious villa, or anything in between, just tell me your preferences and I'll search our database for you.",
                    "Hi there! 🏠 Welcome to our real estate assistant! I'm here to help you discover amazing properties that match your needs. What type of property are you looking for today?",
                    "Greetings! ✨ I'm your personal real estate agent assistant. I can help you find properties based on your budget, location preferences, and desired features. What would you like to search for?"
                ];
                
                return greetings[Math.floor(Math.random() * greetings.length)];
            }

            /**
             * Get predefined response for rate limiting (NO AI CALL)
             */
            getPredefinedResponse(message) {
                const responses = [
                    "I understand! I'm here to help you with all your real estate needs. Feel free to tell me about any specific properties you're looking for.",
                    "Thank you for your message! I'm ready to assist you in finding the perfect property. What are your preferences?",
                    "I appreciate your patience! Let me know what type of property you're interested in and I'll search for options that match your criteria."
                ];
                
                return responses[Math.floor(Math.random() * responses.length)];
            }

            /**
             * Handle property search with optimized workflow
             */
            async handlePropertySearchOptimized(message) {
                try {
                    // Step 1: Extract filters using REGEX ONLY (NO AI CALL)
                    const filters = this.propertyFetcher.extractFilters(message);
                    console.log("Extracted filters (regex only):", filters);

                    // Step 2: Search properties if we have meaningful filters
                    const hasFilters = Object.keys(filters).length > 0;
                    let properties = [];
                    
                    if (hasFilters) {
                        // Fetch properties based on filters (1 WP REST API call)
                        properties = await this.propertyFetcher.fetchProperties(filters);
                        console.log("Fetched properties:", properties);
                        this.state.userContext.lastSearchFilters = filters;
                    }

                    // Step 3: Generate AI response (1 AI CALL ONLY)
                    let response;
                    if (!this.rateLimiter.canMakeRequest()) {
                        // Rate limited - use predefined response
                        if (properties.length > 0) {
                            response = `Great! I found ${properties.length} properties that match your criteria. Here are the details:`;
                        } else if (hasFilters) {
                            response = "I searched for properties matching your criteria, but didn't find any results. You might want to adjust your search parameters or try a different location.";
                        } else {
                            response = "I'd love to help you find the perfect property! Could you share more details about what you're looking for? For example, your preferred location, budget range, or type of property?";
                        }
                    } else {
                        // Use AI for a better response
                        const propertyInfo = this.propertyFetcher.formatPropertiesForAI(properties);
                        const searchPrompt = `User's request: "${message}"

Search results: ${properties.length > 0 ? `Found ${properties.length} properties` : 'No properties found'}
${properties.length > 0 ? 'Property details:\n' + propertyInfo : 'You may suggest adjusting search criteria.'}

Respond as a professional real estate agent. ${properties.length > 0 ? 'Briefly highlight the search results and mention that property cards will be shown below.' : 'Ask for more specific criteria or suggest alternatives.'} Keep it helpful and engaging.`;

                        response = await this.callAPI(searchPrompt);
                    }
                    
                    return { response, properties };
                    
                } catch (error) {
                    if (error.message.includes('Too many requests')) {
                        return { 
                            response: "I'm experiencing high demand right now. Let me search for properties based on what you mentioned.", 
                            properties: [] 
                        };
                    }
                    throw error;
                }
            }

            /**
             * Handle general conversation (1 AI call only)
             */
            async handleGeneralConversation(message) {
                this.rateLimiter.recordRequest();
                
                const conversationPrompt = `User said: "${message}"

Respond as a helpful real estate agent. Keep it natural and conversational. If they're asking general questions about real estate, provide helpful information. If they seem interested in properties but haven't specified details, gently guide them toward sharing their preferences.`;

                return await this.callAPI(conversationPrompt);
            }

            /**
             * Display property cards in the chat
             */
            displayPropertyCards(properties) {
                const formattedProperties = this.propertyFetcher.formatPropertiesForDisplay(properties);
                
                if (!formattedProperties || formattedProperties.length === 0) {
                    return;
                }

                const cardsContainer = document.createElement('div');
                cardsContainer.className = 'message bot-message';
                cardsContainer.style.marginTop = '10px';

                const avatarDiv = document.createElement('div');
                avatarDiv.className = 'message-avatar bot-avatar';
                const avatarImg = document.createElement('img');
                avatarImg.src = this.config.botAvatarMessageUrl;
                avatarImg.alt = `${this.config.botName} Avatar`;
                avatarImg.onerror = () => {
                    avatarDiv.innerHTML = '🏠';
                    avatarDiv.style.fontSize = '16px';
                    avatarDiv.style.color = '#666';
                };
                avatarDiv.appendChild(avatarImg);

                const contentDiv = document.createElement('div');
                contentDiv.className = 'message-content';
                contentDiv.style.maxWidth = '90%';
                contentDiv.style.padding = '8px';

                formattedProperties.forEach(property => {
                    const card = this.createPropertyCard(property);
                    contentDiv.appendChild(card);
                });

                cardsContainer.appendChild(avatarDiv);
                cardsContainer.appendChild(contentDiv);
                
                this.elements.messagesContainer.appendChild(cardsContainer);
                this.scrollToBottom();
            }

            /**
             * Create a property card element
             */
            createPropertyCard(property) {
                const card = document.createElement('div');
                card.className = 'property-card';

                const imageLoadError = `this.src='https://via.placeholder.com/300x200/e0e0e0/666666?text=Property+Image'; this.onerror=null;`;

                card.innerHTML = `
                    <img src="${property.image}" alt="${property.title}" class="property-image" 
                         onerror="${imageLoadError}">
                    <div class="property-details">
                        <div class="property-title">${this.escapeHtml(property.title)}</div>
                        <div class="property-price">${this.escapeHtml(property.price)}</div>
                        <div class="property-specs">
                            <span>🛏️ ${this.escapeHtml(property.bedrooms)} bed</span>
                            <span>🚿 ${this.escapeHtml(property.bathrooms)} bath</span>
                            <span>📐 ${this.escapeHtml(property.area)}</span>
                        </div>
                        <div class="property-location">
                            📍 ${this.escapeHtml(property.location)}
                        </div>
                        <a href="${property.link}" target="_blank" class="property-link" rel="noopener noreferrer">View Details</a>
                    </div>
                `;

                return card;
            }

            /**
             * Escape HTML to prevent XSS
             */
            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            /**
             * Call the AI API with enhanced error handling
             */
            async callAPI(userMessage) {
                const messages = [
                    {
                        role: 'system',
                        content: `You are ${this.config.botName}, a professional and knowledgeable real estate agent AI assistant. You help clients find their perfect property by:

1. Understanding their needs through natural conversation
2. Gathering information about budget, location, property type, and features
3. Presenting relevant properties from search results
4. Providing detailed information about properties
5. Offering expert advice on real estate matters

Guidelines:
- Be friendly, professional, and helpful
- Have natural conversations - don't always search for properties immediately
- Ask clarifying questions when needed to better understand their needs
- When showing properties, highlight key features
- Provide realistic market insights
- Use emojis occasionally to make conversations more engaging
- Keep responses concise but informative
- If someone greets you, greet them back warmly before diving into business

Remember: Build rapport first, then help them find properties.`
                    },
                    ...this.state.conversationMemory,
                    {
                        role: 'user',
                        content: userMessage
                    }
                ];
                
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 20000); // 20 second timeout
                
                try {
                    const response = await fetch(this.config.apiUrl, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${this.config.apiKey}`,
                            'Content-Type': 'application/json',
                            'HTTP-Referer': window.location.origin,
                            'X-Title': 'Real Estate Chatbot'
                        },
                        body: JSON.stringify({
                            model: this.config.model,
                            messages: messages,
                            max_tokens: this.config.maxTokens,
                            temperature: this.config.temperature
                        }),
                        signal: controller.signal
                    });
                    
                    clearTimeout(timeoutId);
                    
                    if (response.status === 429) {
                        const retryAfter = response.headers.get('retry-after') || 60;
                        this.rateLimiter.setRetryAfter(parseInt(retryAfter));
                        throw new Error(`Too many requests. Please wait ${retryAfter} seconds and try again.`);
                    }
                    
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(`API Error ${response.status}: ${errorData.error?.message || 'Request failed'}`);
                    }
                    
                    const data = await response.json();
                    
                    if (!data.choices?.[0]?.message?.content) {
                        throw new Error('Invalid response format from API');
                    }
                    
                    return data.choices[0].message.content;
                    
                } catch (error) {
                    if (error.name === 'AbortError') {
                        throw new Error('Request timeout. Please try again.');
                    }
                    throw error;
                } finally {
                    clearTimeout(timeoutId);
                }
            }

            /**
             * Add message to memory
             */
            addToMemory(userMessage, botResponse) {
                this.state.conversationMemory.push(
                    { role: 'user', content: userMessage },
                    { role: 'assistant', content: botResponse }
                );
                
                while (this.state.conversationMemory.length > this.state.maxMemorySize * 2) {
                    this.state.conversationMemory.shift();
                }
            }

            /**
             * Add message to chat display
             */
            addMessage(text, sender) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${sender}-message`;
                
                const avatarDiv = document.createElement('div');
                avatarDiv.className = `message-avatar ${sender === 'bot' ? 'bot-avatar' : 'user-message-avatar'}`;
                
                if (sender === 'bot') {
                    const avatarImg = document.createElement('img');
                    avatarImg.src = this.config.botAvatarMessageUrl;
                    avatarImg.alt = `${this.config.botName} Avatar`;
                    avatarImg.onerror = () => {
                        avatarDiv.innerHTML = '🏠';
                        avatarDiv.style.fontSize = '16px';
                        avatarDiv.style.color = '#666';
                    };
                    avatarDiv.appendChild(avatarImg);
                } else {
                    const avatarImg = document.createElement('img');
                    avatarImg.src = this.config.userAvatarUrl;
                    avatarImg.alt = 'Your Avatar';
                    avatarImg.style.width = '100%';
                    avatarImg.style.height = '100%';
                    avatarImg.style.objectFit = 'cover';
                    
                    avatarImg.onerror = () => {
                        avatarDiv.innerHTML = 'U';
                        avatarDiv.style.fontSize = '14px';
                        avatarDiv.style.fontWeight = 'bold';
                        avatarDiv.style.color = 'white';
                        avatarDiv.style.display = 'flex';
                        avatarDiv.style.alignItems = 'center';
                        avatarDiv.style.justifyContent = 'center';
                    };
                    
                    avatarDiv.appendChild(avatarImg);
                }
                
                const contentDiv = document.createElement('div');
                contentDiv.className = 'message-content';
                
                if (sender === 'bot' && this.config.enableMarkdown) {
                    contentDiv.innerHTML = MarkdownParser.parse(text);
                } else {
                    contentDiv.textContent = text;
                }
                
                messageDiv.appendChild(avatarDiv);
                messageDiv.appendChild(contentDiv);
                
                this.elements.messagesContainer.appendChild(messageDiv);
                this.scrollToBottom();
            }

            /**
             * Show typing indicator
             */
            showTypingIndicator() {
                this.hideTypingIndicator();
                this.state.isTyping = true;
                
                const typingDiv = document.createElement('div');
                typingDiv.className = 'typing-indicator-message';
                typingDiv.id = 'typing-indicator';
                typingDiv.setAttribute('role', 'status');
                typingDiv.setAttribute('aria-label', `${this.config.botName} is typing`);

                const avatarDiv = document.createElement('div');
                avatarDiv.className = 'message-avatar bot-avatar';
                const avatarImg = document.createElement('img');
                avatarImg.src = this.config.botAvatarMessageUrl;
                avatarImg.alt = `${this.config.botName} Avatar`;
                avatarImg.onerror = () => {
                    avatarDiv.innerHTML = '🏠';
                    avatarDiv.style.fontSize = '16px';
                    avatarDiv.style.color = '#666';
                };
                avatarDiv.appendChild(avatarImg);

                const indicatorDiv = document.createElement('div');
                indicatorDiv.className = 'typing-indicator';
                indicatorDiv.innerHTML = `
                    <div class="typing-dots">
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                        <div class="typing-dot"></div>
                    </div>
                `;

                typingDiv.appendChild(avatarDiv);
                typingDiv.appendChild(indicatorDiv);
                this.elements.messagesContainer.appendChild(typingDiv);
                this.scrollToBottom();
            }

            /**
             * Hide typing indicator
             */
            hideTypingIndicator() {
                const indicator = document.getElementById('typing-indicator');
                if (indicator) {
                    indicator.remove();
                }
                this.state.isTyping = false;
            }

            /**
             * Show initial message
             */
            showInitialMessage() {
                this.addMessage(this.config.initialMessage, 'bot');
            }

            /**
             * Update connection status
             */
            updateConnectionStatus(status) {
                const { statusDot, statusText, statusMessage } = this.elements;
                
                switch (status) {
                    case 'online':
                        statusDot.className = 'status-dot';
                        statusText.textContent = 'Online';
                        statusMessage.textContent = 'Online';
                        break;
                    case 'failed':
                        statusDot.className = 'status-dot failed';
                        statusText.textContent = 'Connection Failed';
                        statusMessage.textContent = 'Failed';
                        break;
                    case 'rate-limited':
                        statusDot.className = 'status-dot rate-limited';
                        statusText.textContent = 'Rate Limited';
                        statusMessage.textContent = 'Busy';
                        break;
                    case 'connecting':
                        statusDot.className = 'status-dot';
                        statusText.textContent = 'Connecting';
                        statusMessage.textContent = 'Connecting...';
                        break;
                }
            }

            /**
             * Show rate limit warning
             */
            showRateLimitWarning(waitTime) {
                this.updateConnectionStatus('rate-limited');
                
                const warningDiv = document.createElement('div');
                warningDiv.className = 'rate-limit-warning';
                warningDiv.setAttribute('role', 'alert');
                warningDiv.innerHTML = `
                    <span>⏱️ I'm getting a lot of requests right now. Please wait ${waitTime} seconds before sending another message.</span>
                `;
                
                this.elements.messagesContainer.appendChild(warningDiv);
                this.scrollToBottom();
                
                setTimeout(() => {
                    if (warningDiv.parentNode) {
                        warningDiv.remove();
                    }
                    this.updateConnectionStatus('online');
                }, waitTime * 1000);
            }

            /**
             * Handle API errors with user-friendly messages
             */
            handleAPIError(error) {
                console.error("Real Estate Chatbot API Error:", error);
                
                let errorMessage;
                let statusType = 'failed';
                const errorString = error.message || '';
                
                if (errorString.includes('401')) {
                    errorMessage = "Authentication failed. Please check the API configuration.";
                } else if (errorString.includes('429') || errorString.includes('Too many requests')) {
                    errorMessage = "I'm receiving too many requests right now. Please wait a moment and try again.";
                    statusType = 'rate-limited';
                } else if (errorString.includes('500')) {
                    errorMessage = "Server error. Please try again in a few moments.";
                } else if (errorString.includes('timeout') || errorString.includes('Failed to fetch')) {
                    errorMessage = "Network error. Please check your internet connection and try again.";
                } else {
                    errorMessage = "I'm having trouble connecting right now. Please try again in a moment.";
                }
                
                this.updateConnectionStatus(statusType);
                this.showErrorMessage(errorMessage);
                
                setTimeout(() => {
                    this.updateConnectionStatus('online');
                }, 10000);
            }

            /**
             * Show error message in chat
             */
            showErrorMessage(message) {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error-message';
                errorDiv.setAttribute('role', 'alert');
                errorDiv.innerHTML = `
                    <svg viewBox="0 0 24 24" aria-hidden="true">
                        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>
                    </svg>
                    <span>${message}</span>
                `;
                
                this.elements.messagesContainer.appendChild(errorDiv);
                this.scrollToBottom();
                
                setTimeout(() => {
                    if (errorDiv.parentNode) {
                        errorDiv.remove();
                    }
                }, 15000);
            }

            /**
             * Scroll messages to bottom
             */
            scrollToBottom() {
                requestAnimationFrame(() => {
                    this.elements.messagesContainer.scrollTop = this.elements.messagesContainer.scrollHeight;
                });
            }

            // Public API methods
            open() { this.openChat(); }
            close() { this.closeChat(); }
            
            sendCustomMessage(message, sender = 'user') {
                this.addMessage(message, sender);
                if (sender === 'user') {
                    this.processUserMessage(message);
                }
            }
            
            updateConfig(newConfig) {
                this.config = { ...this.config, ...newConfig };
                this.applyConfiguration();
            }
        }

        // Initialize the real estate chatbot when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            // Real Estate Chatbot Configuration
            const chatbotConfig = {
                // Basic Settings
                botName: 'Real Estate AI Agent',
                botAvatarHeaderUrl: 'https://cdn-icons-png.flaticon.com/256/3135/3135715.png',
                botAvatarMessageUrl: 'https://cdn-icons-png.flaticon.com/256/3135/3135715.png',
                userAvatarUrl: 'https://cdn-icons-png.flaticon.com/256/9131/9131529.png',
                
                // Theme Colors
                primaryColor: '#000080',
                secondaryColor: '#3b82f6',
                
                // Messages
                initialMessage: "🏠 Hello! I'm your AI real estate agent. I'm here to help you find the perfect property. Just tell me what you're looking for - location, budget, property type, or any specific features you need!",
                
                // API Configuration - REPLACE WITH YOUR ACTUAL API KEY
                apiKey: 'YOUR_OPENROUTER_API_KEY_HERE',
                apiUrl: 'https://openrouter.ai/api/v1/chat/completions',
                model: 'mistralai/mistral-small-3.2-24b-instruct:free',
                maxTokens: 800,
                temperature: 0.7,
                
                // WordPress Property API Configuration - REPLACE WITH YOUR ACTUAL ENDPOINT
                propertyApiUrl: 'https://yourdomain.com/wp-json/wp/v2/property',
                
                // Feature Settings
                enableAttachments: false,
                enableMarkdown: true,
                autoCloseOnOutsideClick: false,
                showTypingIndicator: true,
                errorRetryAttempts: 3
            };
            
            // Create the real estate chatbot instance
            window.realEstateChatbot = new RealEstateChatBot(chatbotConfig);
        });
    </script>
</body>
</html>

